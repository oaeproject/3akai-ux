/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

define(['jquery', 'underscore', 'oae.core'], function($, _, oae) {

    return function(uid) {

        // The widget container
        var $rootel = $('#' + uid);

        // Variable that will be used to keep track of the current infinite scroll instance
        var infinityScroll = false;

        /**
         * Sort entities based on whether or not they have a thumbnail. Entities with
         * thumbnails will be listed in front of those with no thumbnails, as we give
         * preference to these for UI rendering purposes.
         *
         * @see Array#sort
         */
        var sortEntityCollection = function(a, b) {
            if (a.image && !b.image) {
                return -1;
            } else if (!a.image && b.image) {
                return 1;
            }
            return 0;
        };

        /**
         * Process the incoming activities by sorting the actor entity collections on whether or not they have
         * thumbnail images, as we give preference to these for UI rendering purposes.
         *
         * @param  {Object}    data     The current user's notifications per the activitystrea.ms spec
         * @return {Object}             Object containing the notifications where the actors are sorted on whether or not they have a profile image
         */
        var processActivities = function(data) {
            $.each(data.items, function(index, activity) {
                // Sort the actor entity collections based on whether or not they have a thumbnail
                if (activity.actor['oae:collection']) {
                    activity.actor['oae:collection'].sort(sortEntityCollection);
                }
            });
            return {'results': data.items};
        };

        /**
         * Based on the timestamp at which the user last read the notifications, all notifications that happened
         * after that time are marked as unread. This will make it clearer to the end-user as to which notifications
         * he should be paying most attention to.
         */
        var flagUnread = function() {
            // Remove the unread style from all items
            $('.oae-listitem', $rootel).removeClass('alert-info');
            // Add the unread style to all items that happened after the last time the notifications
            // were read by the user
            var notificationsLastRead = oae.data.me.notificationsLastRead || 0;
            $('.oae-listitem', $rootel).each(function() {
                var $notification = $(this);
                if (parseInt($notification.attr('data-published'), 10) > notificationsLastRead) {
                    // The standard `alert-info` class is used for flagging
                    $notification.addClass('alert-info');
                }
            });
        };

        /**
         * When the clickover is closed, we assume that the user has seen all of its unread notifications and mark
         * all of them as read.
         */
        var markAsRead = function() {
            // Reset the number of unread notifications on the back-end side
            $.ajax({
                'url': '/api/notifications/markRead',
                'type': 'POST'
            });
        };

        /**
         * Remove the unread notification count from the top navigation widget
         */
        var removeUnreadCount = function() {
            $('#topnavigation-notification-count').hide();
            // Reset the number of unread notifications in the me feed object and
            // the time at which the notifications were read last
            oae.data.me.notificationsLastRead = Date.now();
            oae.data.me.notificationsUnread = 0;

            // Reset the number on the favicon
            oae.api.util.setFavicon(0);
        };

        /**
         * Initialize a new infinite scroll container that fetches the current user's notifications.
         */
        var getNotifications = function() {
            // At this point, we need to make sure that the clickover is wide enough to be able to show notifications
            $('#notifications-container', $rootel).parents('.popover').removeClass('notifications-empty-container');

            // Disable the previous infinite scroll
            if (infinityScroll) {
                infinityScroll.kill();
            }

            // Set up the infinite scroll for the notifications list
            infinityScroll = $('.oae-list', $rootel).infiniteScroll('/api/notifications', {
                'limit': 6
            }, '#notifications-template', {
                'scrollContainer': $('#notifications-container', $rootel),
                'postProcessor': processActivities,
                'postRenderer': flagUnread,
                'emptyListProcessor': handleEmptyResultList
            });
        };

        /**
         * Show the empty list message when no notifications are found. This function will
         * be called by the infinite scroll plugin.
         */
        var handleEmptyResultList = function() {
            // When no notifications are available, the clickover doesn't need to be as wide as when notifications
            // are shown. Therefore, we apply a class to the popover container that makes the clickover smaller
            $('#notifications-container', $rootel).parents('.popover').addClass('notifications-empty-container');
            oae.api.util.template().render($('#notifications-noresults-template', $rootel), null, $('.oae-list', $rootel));
        };

        /**
         * Subscribe to notification push notifications, allowing for new notifications to be added to the
         * notification stream straight away
         */
        var setUpPushNotifications = function() {
            oae.api.push.subscribe(oae.data.me.id, 'notification', oae.data.me.signature, 'activitystreams', true, function(activity) {
                // Prepend the new notification to the notification stream
                infinityScroll.prependItems({'items': [activity]});
                // The new notifications are marked as read when the notification popover is visible,
                // and therefore the new notification will have been seen by the user
                if ($rootel.is(':visible')) {
                    markAsRead();
                }
            });
        };

        /**
         * Initializes the notifications clickover
         */
        var setUpNotificationsClickover = function() {
            $(document).on('click', '.oae-trigger-notifications', function() {
                // Trigger the notifications clickover
                oae.api.util.clickover($(this), $('.notifications-widget'), {
                    'onShown': function($currentRootEl) {
                        $rootel = $currentRootEl;
                        getNotifications();
                        // The notifications need to be marked as read straight away, in case the user
                        // follows a link in the notifications and doesn't actually end up closing the
                        // clickover on the current page
                        markAsRead();
                    },
                    'onHidden': removeUnreadCount
                });
            });
        };

        setUpPushNotifications();
        setUpNotificationsClickover();

    };
});
