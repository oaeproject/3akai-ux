/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

// TODO: Remove this
var sakai_global = sakai_global || {};
sakai_global.contentauthoring = sakai_global.contentauthoring || {};

define(['jquery', 'underscore', 'oae.core'], function($, _, oae) {

    return function(uid, showSettings) {

        // Element cache
        var $rootel = $('#' + uid);
        var $pageRootEl = false;

        // Configuration variables
        var MINIMUM_COLUMN_SIZE = 0.10;
        var DEFAULT_WIDGET_SETTINGS_WIDTH = 650;
        var CONCURRENT_EDITING_INTERVAL = 5000;

        // Help variables
        var pagesCache = {};
        var currentPageShown = {};
        var storePath = false;
        var isDragging = false;
        var editInterval = false;
        var uniqueModifierId = oae.api.util.generateId();
        var pageTitle = '';

        ///////////////////////
        // Utility functions //
        ///////////////////////

        /**
         * Check whether the current page is shown in edit mode
         * or view mode. True will be returned when the page is in
         * edit mode. False will be returned when the page is in
         * view mode
         */
        var isInEditMode = function() {
            return $rootel.hasClass('contentauthoring_edit_mode');
        };

        /**
         * Check whether the current user can edit the current page. The user
         * can't edit the page if he doesn't have permission or if the page
         * is non-editable
         */
        var canEditCurrentPage = function() {
            return (currentPageShown.canEdit && !currentPageShown.nonEditable);
        };

        /**
         * Returns an array of widget ids for all of the widgets that are
         * embedded in the current page
         */
        var getWidgetList = function() {
            var widgetIDs = [];
            for (var r = 0; r < currentPageShown.content.rows.length; r++) {
                for (var c = 0; c < currentPageShown.content.rows[r].columns.length; c++) {
                    for (var e = 0; e < currentPageShown.content.rows[r].columns[c].elements.length; e++) {
                        widgetIDs.push(currentPageShown.content.rows[r].columns[c].elements[e]);
                    }
                }
            }
            return widgetIDs;
        };

        /**
         * Removes highlight zones when not dragging in edit mode
         */
        var checkRemoveHighlight = function() {
            if (isInEditMode() && !isDragging) {
                $('.contentauthoring_row_reorder_highlight,.contentauthoring_cell_reorder_highlight').remove();
            }
        };

        /*
         * Generate a drag helper that will be used to drag around when dragging a row or
         * a widget (instead of the actual element). Using a drag helper prevents
         */
        var generateDragHelper = function(ev, ui) {
            var $el = $('<div/>');
            $el.css('width', ui.width() + 'px');
            $el.css('height', ui.height() + 'px');
            $el.addClass('contentauthoring_reorder_placeholder');
            return $el;
        };

        /////////////////////
        // TINYMCE RELATED //
        /////////////////////

        /**
         * De-initialize all of the tinyMCE editors in a given container. This is necessary
         * when dragging or moving an element that contains a tinyMCE editor
         * @param {jQuery} $container   Container in which to de-initialize tinyMCE
         */
        var killTinyMCEInstances = function($container) {
            $container.find('.tinyMCE').each(function() {
                tinyMCE.execCommand('mceRemoveControl', false, $(this).attr('id'));
            });
        };

        /**
         * Initialize all of the tinyMCE declarations inside of a given container. This
         * needs to be called after dragging or moving an element containing a tinyMCE editor.
         * @param {jQuery} $container   Container in which to initialize tinyMCE
         */
        var initializeTinyMCEInstances = function($container) {
            $container.find('.tinyMCE').each(function() {
                tinyMCE.execCommand('mceAddControl', true, $(this).attr('id'));
                tinyMCEInstanceFix();
            });
        };

        /**
         * Fix for https://jira.sakaiproject.org/browse/SAKIII-4878
         * This fix makes sure that the text edit controls aren't re-initialized
         * when dragging or moving an htmlblock widget
         */
        var tinyMCEInstanceFix = function() {
            $('.htmlblock_widget', $rootel).find('.mceExternalToolbar').hide();
            $.each($('#inserterbar_widget .mceAction', $rootel).children('.mceColorPreview'), function(i, color) {
                if (i > 0) {
                    $(color).hide();
                }
            });
        };

        /**
         * Hide the tinyMCE toolbar
         */
        var hideTinyMCEFormatBar = function() {
            $('#inserterbar_tinymce_container', $rootel).hide();
        };

        ////////////////////
        ////////////////////
        // ROW MANAGEMENT //
        ////////////////////
        ////////////////////

        ////////////////////
        // ROW REORDERING //
        ////////////////////

        /**
         * Make the rows inside of the current page re-orderable
         */
        var makeRowsReorderable = function() {
            $('#contentauthoring_widget_container', $pageRootEl).sortable({
                handle: '.contentauthoring_row_handle',
                placeholder: 'contentauthoring_row_reorder_highlight',
                opacity: 0.4,
                helper: generateDragHelper,
                start: function(ev, ui) {
                    hideTinyMCEFormatBar();
                    killTinyMCEInstances($(ui.item));
                    isDragging = true;
                    $('.contentauthoring_row_handle_container', $rootel).css('visibility', 'hidden');
                    $('.contentauthoring_cell_element_actions', $rootel).hide();
                    hideEditRowMenu();
                },
                stop: function(event, ui) {
                    initializeTinyMCEInstances($(ui.item));
                    $(this).sortable('refresh');
                    isDragging = false;
                    storeCurrentPageLayout();
                }
            });
            setRowHover();
        };

        ///////////////
        // ROW HOVER //
        ///////////////

        var setRowHoverIn = function(e, $container) {
            var $el = $(this);
            if ($container) {
                $el = $container;
            }
            // Only show the hover state when we are in edit mode and we are not dragging an element
            if (isInEditMode() && !isDragging) {
                $('.contentauthoring_row_handle_container', $el).css('visibility', 'visible');
            }
        };

        var setRowHoverOut = function(e, $container) {
            var $el = $(this);
            if ($container) {
                $el = $container;
            }
            $('.contentauthoring_row_handle_container', $el).css('visibility', 'hidden');
        };

        /**
         * Set the onhover and onhoverout functions for each row. When hovering over a
         * row, the edit row menu will be shown. When hovering out of it, it will be
         * hidden
         */
        var setRowHover = function() {
            $('.contentauthoring_row_container', $rootel).off('hover');
            $('.contentauthoring_row_container', $rootel).hover(setRowHoverIn, setRowHoverOut);
        };

        //////////////////////
        // ADDING A NEW ROW //
        //////////////////////

        /**
         * Returns the HTML for a new and empty row
         */
        var generateNewRow = function() {
            // Create an empty row
            var newRow = {
                'id': sakai.api.Util.generateWidgetId(),
                'template': 'row',
                'sakai': sakai,
                'columns': [
                    {
                        'width': 1,
                        'elements': [
                            {
                                'dummytext': true
                            }
                        ]
                    }
                ]
            };
            newRow.template = 'row';
            newRow.sakai = sakai;
            // Return the row HTML
            return sakai.api.Util.TemplateRenderer('contentauthoring_widget_template', newRow, false, false);
        };

        //////////////////////
        // ROW CONTEXT MENU //
        //////////////////////

        // Variable that keeps track of the rowid for which the contextmenu
        // is currently displaying
        var rowToChange = false;

        /**
         * Hide the edit row dropdown
         */
        var hideEditRowMenu = function() {
            rowToChange = false;
            $('#contentauthoring_row_menu', $rootel).hide();
            $('.contentauthoring_row_handle_container', $rootel).removeClass('selected');
        };

        /**
         * Show the edit row dropdown (if it is not already open).
         * @param {Object} ev   jQuery event object
         */
        var showEditRowMenu = function(ev) {
            var currentRow = $(this).attr('data-row-id');
            // If the clicked row is the same as the row that is already open, we
            // hide the menu
            if (currentRow === rowToChange) {
                hideEditRowMenu();
            } else {
                // If there is more than 1 row on the screen, we can show the 'Remove row' option
                // If there is only 1 row, we should hide that option
                var show = ($('.contentauthoring_row', $('#' + currentPageShown.ref)).length > 1);
                $('#contentauthoring_row_menu_remove', $rootel).parent('li').toggle(show);
                $(this).parents('.contentauthoring_row_handle_container').addClass('selected');
                var $rowMenu = $('#contentauthoring_row_menu', $rootel);
                $rowMenu.css({
                    'left': $(this).parent().position().left + 'px',
                    'top': ($(this).parent().position().top + 7) + 'px'
                }).show();
                $rowMenu.find('button:visible:first').focus();
                rowToChange = currentRow;
                checkColumnsUsed($(this).parents('.contentauthoring_row_container'));
            }
        };

        /**
         * Matches the number of columns to the 'columncount' data attribute on list items
         * that indicates how many are used and puts a black check icon in front of the list item
         * @param {jQuery} element jQuery object with classname 'contentauthoring_row_container'
         *                         that is the parent element of all columns
         */
        var checkColumnsUsed = function(element) {
            var numColumns = $(element).find('.contentauthoring_cell.ui-resizable').length;
            var $menuItems = $('#contentauthoring_row_menu ul li', $rootel);
            $.each($menuItems, function(i, item) {
                var $item = $(item);
                $item.find('.oae-action-icon').removeClass('oae-black-check-icon');
                if ($item.data('columncount') === numColumns) {
                    $item.find('.oae-action-icon').addClass('oae-black-check-icon');
                }
            });
        };

        ///////////////////////
        ///////////////////////
        // COLUMN MANAGEMENT //
        ///////////////////////
        ///////////////////////

        /////////////////////
        // COLUMN RESIZING //
        /////////////////////

        //
        var currentSizes = [];

        /**
         * Returns an array of relative widths for all of the columns in a given row
         * @param {jQuery} $row     jQuery element representing row for which to get the widths
         *                          of its columns
         */
        var getColumnWidths = function($row) {
            var totalWidth = $('#contentauthoring_widget_container', $pageRootEl).width();
            var $cells = $('.contentauthoring_cell', $row);
            var widths = [];
            // Variable to track the remaining width
            var lastWidth = 1;
            for (var i = 0; i < $cells.length; i++) {
                // We give the last column the remaining width
                if (i === $cells.length - 1) {
                    widths.push(lastWidth);
                // We give each column a relative width rather than
                // an absolute one
                } else {
                    lastWidth -= $($cells[i]).width() / totalWidth;
                    widths.push($($cells[i]).width() / totalWidth);
                }
            }
            return widths;
        };

        /**
         * Make all of the columns in the current page resizable
         */
        var makeColumnsResizable = function() {
            $(window).trigger('resize.contentauthoring.sakai');
            $('.contentauthoring_cell', $rootel).resizable({
                handles: {
                    'e': '.contentauthoring_cell_handle,.contentauthoring_cell_handle_grab'
                },
                disabled: false,
                helper: 'ui-resizable-helper',
                start: function(event, ui) {
                    hideTinyMCEFormatBar();
                    sakai.api.Util.Draggable.setIFrameFix();
                    isDragging = true;
                    var $row = $(this).parent();
                    currentSizes = getColumnWidths($row);
                },
                stop: function(ev, ui) {
                    sakai.api.Util.Draggable.removeIFrameFix();
                    isDragging = false;
                    var $row = $(this).parent();
                    recalculateColumnWidths(ui, $row, $(this), currentSizes);
                    setRowHeight($row);
                    $(window).trigger('resize.contentauthoring.sakai');
                    storeCurrentPageLayout();
                }
            });
        };

        /**
         * Recalculate the widths of all the columns in a row after having resized a column. This
         * makes sure that each of the columns has sufficient width, ratios between the non-dragged
         * columns are preserved, etc.
         * @param {Object} ui             jQuery ui object
         * @param {jQuery} $row           jQuery element representing the row we're calculating
         *                                widths for
         * @param {jQuery} $resizedCell   jQuery element representing the column that's being resized
         * @param {Array} currentSizes    The arrray containing the current column widths, used
         *                                to preserve the column width ratios
         */
        var recalculateColumnWidths = function(ui, $row, $resizedCell, currentSizes) {
            var totalRowWidth = $('#contentauthoring_widget_container', $pageRootEl).width();
            var newColumnWidth = (ui.size.width + 12) / totalRowWidth;
            var oldColumnWidth = ui.originalSize.width / totalRowWidth;

            var rowId = $row.attr('data-row-id');
            var $cells = $('.contentauthoring_cell', $row);

            var hasFoundResizedCell = false;

            var totalWidth = 0;
            var numberOfColumns = $cells.length;
            for (var i = 0; i < $cells.length; i++) {
                var currentColumnWidth = 0;
                if ($($cells[i]).is($resizedCell)) {
                    // New percentage based width
                    if (newColumnWidth < MINIMUM_COLUMN_SIZE) {
                        currentColumnWidth = MINIMUM_COLUMN_SIZE;
                    } else if (totalWidth + newColumnWidth + ((numberOfColumns - i - 1) * MINIMUM_COLUMN_SIZE) > 1) {
                        currentColumnWidth = 1 - totalWidth - ((numberOfColumns - i - 1) * MINIMUM_COLUMN_SIZE);
                    } else {
                        currentColumnWidth = newColumnWidth;
                    }
                    $($cells[i]).css('width', currentColumnWidth * 100 + '%');
                    hasFoundResizedCell = true;
                } else if (hasFoundResizedCell) {
                    // New percentage based width
                    if (numberOfColumns - i === 1) {
                        // This is the final cell, fill it up
                        currentColumnWidth = 1 - totalWidth;
                    } else {
                        // There are 2 more cells
                        // Does the 2nd have enough space after pulling in the 1st?
                        if (1 - (totalWidth + currentSizes[i]) > MINIMUM_COLUMN_SIZE) {
                            currentColumnWidth = currentSizes[i];
                            $($cells[i + 1]).css('width', (1 - totalWidth - currentSizes[i]) * 100 + '%');
                        // Shrink the fist to its maximum size
                        // Make the second its minumum size
                        } else {
                            currentColumnWidth = 1 - totalWidth - MINIMUM_COLUMN_SIZE;
                            $($cells[i + 1]).css('width', MINIMUM_COLUMN_SIZE * 100 + '%');
                        }
                    }
                    $($cells[i]).css('width', currentColumnWidth * 100 + '%');
                    hasFoundResizedCell = false;
                }
                totalWidth += currentColumnWidth;
            }
        };

        /**
         * Sets the height of a row to the heighest column
         * @param {jQuery} $row jQuery object with class '.contentauthoring_table_row.contentauthoring_cell_container_row'
         *                      used to search for child cells that can contain content
         */
        var setRowHeight = function($row) {
            var cells = $('.contentauthoring_cell_content', $row);
            var setDefaultHeight = true;
            $.each(cells, function(index, cell) {
                // Default the height of the cell to auto to avoid that cells stay larger than they should
                $('.contentauthoring_cell_content', $row).css('height', 'auto');
                // Remove whitespace since jQuery :empty selector doesn't ignore it
                var html = $(cell).html().replace(/\s+/, '');
                if (html.length || $(html).hasClass('contentauthoring_dummy_element')) {
                    // There is some content in the row so no default height but the cell height should be considered
                    setDefaultHeight = false;
                }
            });

            if (setDefaultHeight) {
                // No content in the row, set default height
                $('.contentauthoring_cell_content', $row).css('height', 25);
            } else {
                // Some cells have content
                // if row is part of the pageviewer than equalheights doesn't need to be set
                if (!$('.contentauthoring_cell_content', $row).parents('.pageviewer_widget').length) {
                    $('.contentauthoring_cell_content', $row).equalHeightColumns();
                }
            }
        };

        /**
         * Update the height of all column drag handles in all columns of
         * all rows
         */
        var updateColumnHeights = function() {
            var $rows = $('.contentauthoring_row_container');
            for (var r = 0; r < $rows.length; r++) {
                var $columns = $('.contentauthoring_cell', $($rows[r]));
                var $lastColumn = $($columns[$columns.length - 1]);
                $('.contentauthoring_cell_handle', $lastColumn).hide();
                setRowHeight($($rows[r]));
            }
        };

        /**
         * Updates column handles and sends out a resize event
         */
        var updateColumnHandles = function() {
            $('.contentauthoring_cell_handle', $rootel).show();
            $(window).trigger('resize.contentauthoring.sakai');
            updateColumnHeights();
        };

        /**
         * Every time an image is loaded, we adjust the height of the columns of the row
         */
        var imageLoaded = function(ev, image) {
            setRowHeight($(image).parents('.contentauthoring_table_row.contentauthoring_cell_container_row'));
        };

        /**
         * We listen for HTML changes in the page to catch new iamges being
         * loaded, as we need to adjust the row height when this happens
         * @param {Object} changedHTML      The HTML that has been added or removed
         */
        $rootel.contentChange(function(changedHTML) {
            if (isInEditMode()) {
                $(changedHTML).find('img:visible').each(function(i, item) {
                    imageLoaded({}, $(item));
                    $(item).load(function(ev) {
                        imageLoaded(ev, $(ev.currentTarget));
                    });
                });
                updateColumnHeights();
            }
        });

        ////////////////////
        // ADDING COLUMNS //
        ////////////////////

        /**
         * Given a row, add one or more columns to it, preserving the original ratios
         * @param {jQuery} $row             Row in which we're adding columns
         * @param {Integer} totalColumns    Total of columns we need in the row
         */
        var addColumns = function($row, totalColumns) {
            var widths = getColumnWidths($row);
            var $cells = $('.contentauthoring_cell', $row);
            var newColumnWidth = 1 / totalColumns;
            for (var i = widths.length; i < totalColumns; i++) {
                $('.contentauthoring_cell_container_row', $row).append(sakai.api.Util.TemplateRenderer('contentauthoring_widget_template', {
                    'template': 'column',
                    'column': {
                        'width': newColumnWidth,
                        'elements': []
                    },
                    'sakai': sakai
                }, false, false));
            }
            // Assign each of the columns their new width
            for (var w = 0; w < widths.length; w++) {
                var columnWidth = widths[w] * (1 - (newColumnWidth * (totalColumns - widths.length))) * 100 + '%';
                $($cells[w]).css('width', columnWidth);
            }
            setPageEditActions();
            updateColumnHandles();
            storeCurrentPageLayout();
        };

        //////////////////////
        // REMOVING COLUMNS //
        //////////////////////

        /**
         * Given a row, remove one or more columns from it, preserving the original ratios
         * @param {jQuery} $row             Row in which we're adding columns
         * @param {Integer} totalColumns    Total of columns we need in the row
         */
        var removeColumns = function($row, totalColumns) {
            var widths = getColumnWidths($row);
            var remainingWidth = 1;
            var $cells = $('.contentauthoring_cell', $row);
            $row.find('.contentauthoring_dummy_element').remove();
            // Append the content of the columns that will be removed to the last
            // column that will be retained
            for (var i = totalColumns; i < $cells.length; i++) {
                var $cell = $($cells[i]);
                // De- and re-initialize tinyMCE to avoid errors
                killTinyMCEInstances($cell);
                var $cellcontent = $('.contentauthoring_cell_content', $cell).children();
                initializeTinyMCEInstances($('.contentauthoring_cell_content', $($cells[totalColumns - 1])).append($cellcontent));
                $cell.remove();
                remainingWidth -= widths[i];
            }
            for (var l = 0; l < totalColumns; l++) {
                $($cells[l]).css('width', (widths[l] / remainingWidth) * 100 + '%');
            }
            checkColumnsEmpty();
            updateColumnHandles();
            storeCurrentPageLayout();
        };

        //////////////////////////////
        // CHANGE NUMBER OF COLUMNS //
        //////////////////////////////

        /**
         * Change the number of columns in the currently selected row
         * @param {Integer} number   Number of columns the row should get (1-3)
         */
        var changeNumberOfColumns = function(number) {
            var $row = $('.contentauthoring_row_container[data-row-id="' + rowToChange + '"]', $rootel);
            var $cells = $('.contentauthoring_cell', $row);
            if ($cells.length > number) {
                removeColumns($row, number);
            } else if ($cells.length < number) {
                addColumns($row, number);
            }
            hideEditRowMenu();
            setPageEditActions();
            tinyMCEInstanceFix();
            setRowHeight($row);
        };

        //////////////////////////////
        // EMPTY COLUMN PLACEHOLDER //
        //////////////////////////////

        /**
         * Check whether any of the columns in the current page are empty (i.e., they have no widgets
         * inside of them). If so, we add the placeholder widget
         */
        var checkColumnsEmpty = function() {
            $.each($('.contentauthoring_cell_content', $('#contentauthoring_widget', $rootel)), function(i, cellcontainer) {
                if (!$(cellcontainer).find('.contentauthoring_cell_element').length) {
                    if (!$(cellcontainer).find('.contentauthoring_dummy_element').length) {
                        var dummy = $(sakai.api.Util.TemplateRenderer('contentauthoring_dummy_element_template', {}));
                        $(cellcontainer).append(dummy);
                    }
                } else {
                    $(cellcontainer).find('.contentauthoring_dummy_element').remove();
                }
            });
        };


        ///////////////////////
        ///////////////////////
        // WIDGET MANAGEMENT //
        ///////////////////////
        ///////////////////////

        ///////////////////////
        // WIDGET REORDERING //
        ///////////////////////

        /**
         * Make the widgets reorderable across all rows and columns
         */
        var reorderWidgets = function() {
            $('.contentauthoring_cell_content', $rootel).sortable({
                connectWith: '.contentauthoring_cell_content',
                ghost: true,
                handle: '.contentauthoring_row_handle',
                placeholder: 'contentauthoring_cell_reorder_highlight',
                opacity: 0.4,
                tolerance: 'pointer',
                helper: generateDragHelper,
                start: startWidgetOrdering,
                stop: stopWidgetOrdering
            });
        };

        /**
         * Executed when the dragging action starts. At this point, we
         * de-initialize the tinyMCE instances in the dragged widget
         * @param {Object} event     jQuery event object
         * @param {Object} ui        jQuery ui object
         */
        var startWidgetOrdering = function(event, ui) {
            hideTinyMCEFormatBar();
            killTinyMCEInstances($(ui.item));
            sakai.api.Util.Draggable.setIFrameFix();
            isDragging = true;
            $('.contentauthoring_row_handle_container', $rootel).css('visibility', 'hidden');
            $('.contentauthoring_cell_element_actions', $rootel).hide();
            hideEditRowMenu();
        };

        /**
         * Executed when the dragging action stops. At this point, we
         * re-initialize the tinyMCE instance and remove the dummy element
         * if we drop inside of an empty column
         * @param {Object} event     jQuery event object
         * @param {Object} ui        jQuery ui object
         */
        var stopWidgetOrdering = function(event, ui) {
            initializeTinyMCEInstances($(ui.item));
            sakai.api.Util.Draggable.removeIFrameFix();
            $(this).sortable('refresh');
            isDragging = false;
            $('.contentauthoring_dummy_element', $(this)).remove();
            // If we've dragged in a piece of content
            if ($(ui.item).attr('data-contentId') || $(ui.item).attr('data-collectionId')) {
                addExistingElement(event, ui);
            // If we've dragged in a widget
            } else if ($(ui.item).hasClass('inserterbar_widget_draggable')) {
                addNewWidget(event, $(ui.item));
            }
            checkColumnsEmpty();
            storeCurrentPageLayout();
        };

        //////////////////
        // WIDGET HOVER //
        //////////////////

        var showEditCellMenuHoverIn = function(e, $container) {
            var $el = $(this);
            if ($container) {
                $el = $container;
            }
            // Only show the hover state when we are in edit mode and we are not dragging an element
            if (isInEditMode() && !isDragging) {
                $('.contentauthoring_cell_element_actions', $el).css('left', $el.position().left + 'px');
                $('.contentauthoring_cell_element_actions', $el).css('top', ($el.position().top + 1) + 'px');
                $('.contentauthoring_cell_element_actions', $el).show();
                $('.contentauthoring_cell_element_hover', $rootel).removeClass('contentauthoring_cell_element_hover');
                $el.addClass('contentauthoring_cell_element_hover');
            }
        };

        var showEditCellMenuHoverOut = function(e, $container) {
            var $el = $(this);
            if ($container) {
                $el = $container;
            }
            $('.contentauthoring_cell_element_actions', $rootel).hide();
            $el.removeClass('contentauthoring_cell_element_hover');
        };

        /**
         * Show the widget context menu when hovering over the widget and hide it when
         * hovering out of the widget
         */
        var showEditCellMenu = function() {
            $('.contentauthoring_cell_element', $rootel).off('hover').hover(showEditCellMenuHoverIn, showEditCellMenuHoverOut);
        };

        ///////////////////
        // REMOVE WIDGET //
        ///////////////////

        /**
         * Remove a widget from the page
         * @param {Object} ev   jQuery event object
         */
        var removeWidget = function(ev) {
            var $cell = $(this).parents('.contentauthoring_cell_element');
            var $row = $cell.parents('.contentauthoring_table_row.contentauthoring_cell_container_row');
            killTinyMCEInstances($cell);
            if ($(this).parents('.contentauthoring_cell_content').children('.contentauthoring_cell_element').length > 1) {
                $cell.remove();
            } else {
                var dummy = $(sakai.api.Util.TemplateRenderer('contentauthoring_dummy_element_template', {}));
                $cell.replaceWith(dummy);
            }
            setRowHeight($row);
            storeCurrentPageLayout();
        };

        //////////////////
        //////////////////
        // PAGE ACTIONS //
        //////////////////
        //////////////////

        //////////////////
        // PAGE LOADING //
        //////////////////

        /**
         * When the left hand navigation asks for a new page to be rendered, this function will
         * be called
         * @param {Object} _currentPageShown    Object representing the current page
         * @param {Boolean} putInEditMode       Whether or not to put the page into edit mode after
         *                                      rendering. This will be used for new pages
         */
        var processNewPage = function(_currentPageShown, putInEditMode) {
            // If the current page is in edit mode, we take it back
            // into view mode
            if (isInEditMode() && currentPageShown) {
                cancelEditPage(false, true);
            }
            // Check whether this page has already been loaded
            if (currentPageShown && !_currentPageShown.isVersionHistory) {
                pagesCache[currentPageShown.ref] = $.extend(true, {}, currentPageShown);
            }
            currentPageShown = pagesCache[_currentPageShown.ref] || _currentPageShown;
            // Don't cache in version history mode
            if (currentPageShown.isVersionHistory) {
                currentPageShown = _currentPageShown;
            }
            renderPage(currentPageShown);
            // Put the page into edit mode
            if (putInEditMode) {
                editPage();
            }
        };

        /**
         * SAKIII-5647 When you're using world templates, sometimes the
         * items within rows are strings when they should be objects.
         * This makes versions work again
         * @param {Object} rows The rows object that you want to convert
         */
        var convertRows = function(rows) {
            if (rows && $.isArray(rows)) {
                for (var i = 0; i < rows.length; i++) {
                    if (typeof rows[i] === 'string') {
                        rows[i] = $.parseJSON(rows[i]);
                    }
                }
            }
        };

        /**
         * Render a page, including its full layout and all of the widgets that live inside of it
         * @param {Object} currentPageShown     Object representing the current page
         * @param {Boolean} requiresRefresh     Whether or not the page should be fully reloaded (if it
         *                                      has already been loaded), or whether it can be served
         *                                      from cache
         * @param {Boolean} preEdit             If we should just re-render the page before an edit
         */
        var renderPage = function(currentPageShown, requiresRefresh, preEdit) {
            $pageRootEl = $('#' + currentPageShown.ref, $rootel);
            $('#contentauthoring_widget > div:visible', $rootel).hide();
            // Set the path where widgets should be storing their widget data
            storePath = currentPageShown.pageSavePath + '/' + currentPageShown.saveRef;
            // If the page hasn't been loaded before, or we need a refresh after cancelling the
            // page edit, we create a div container for the page
            if ($pageRootEl.length === 0 || requiresRefresh || currentPageShown.isVersionHistory) {
                if (requiresRefresh || currentPageShown.isVersionHistory) {
                    killTinyMCEInstances($pageRootEl);
                    // Remove the old one in case this is caused by a cancel changes option
                    $pageRootEl.remove();
                }
                // Create the new element
                $pageRootEl = $('<div />').attr('id', currentPageShown.ref).attr('data-sakai-container-id', currentPageShown.path);
                // Add element to the DOM
                $('#contentauthoring_widget', $rootel).append($pageRootEl);
                convertRows(currentPageShown.content.rows);
                var pageStructure = $.extend(true, {}, currentPageShown.content);
                pageStructure.template = 'all';
                oae.api.util.renderTemplate($('#contentauthoring_widget_template'), pageStructure, $pageRootEl);
                oae.api.widget.loadWidgets($('#' + currentPageShown.ref), false, currentPageShown.content);
            // If the page has been loaded before, we can just show it again
            } else {
                $pageRootEl.show();
            }

            // Determine whether or not to show the empty page placeholder
            determineEmptyPage(currentPageShown);

            updateColumnHeights();
        };

        ////////////////////////////
        // EMPTY PAGE PLACEHOLDER //
        ////////////////////////////

        /**
         * Checks for empty htmlblock widgets and returns a Boolean
         * @return {Boolean} false if the htmlblock widget is not empty
         *                   true if the htmlblock widget is empty
         */
        var checkHTMLBlockEmpty = function(currentPageShown, element) {
            if (currentPageShown.content[element.id] &&
                currentPageShown.content[element.id].htmlblock &&
                ($.trim($(currentPageShown.content[element.id].htmlblock.content).text()) ||
                $(currentPageShown.content[element.id].htmlblock.content).html())) {
                return false;
            }
            return true;
        };

        /**
         * Determines if a page is empty by checking its content
         * Shows a default image when no content is present in the page
         * Empty content = empty rows and rows with empty html blocks
         * @param {Object} currentPageShown Object containing data for the current page
         */
        var determineEmptyPage = function(currentPageShown) {
            // emptyPageElements checks for empty rows
            var emptyPageElements = true;
            // emptyPageElementContents checks for empty tinyMCe instances
            var emptyPageElementContents = true;

            // Check for empty rows, if a row with content or (empty) tinyMCE is detected emptyPageElements will be set to false
            // emptyPageElements will later be overridden if the tinymce instances don't have any content after all
            $.each(currentPageShown.content.rows, function(rowIndex, row) {
                $.each(row.columns, function(columnIndex, column) {
                    if (column.elements && column.elements.length) {
                        $.each(column.elements, function(elIndex, element) {
                            // Check designed to look at specific storage types
                            if (element.type === 'htmlblock') {
                                // Returns false if not empty, true if empty
                                emptyPageElements = checkHTMLBlockEmpty(currentPageShown, element);
                            } else {
                                emptyPageElements = false;
                            }
                            // If false returned there must be content and the page should be rendered
                            return emptyPageElements;
                        });
                        return emptyPageElements;
                    }
                    return emptyPageElements;
                });
                return emptyPageElements;
            });

            // If the page is empty show the illustration
            showPlaceholder(emptyPageElements);
        };

        /**
         * Determine whether the current page is completely empty after editting
         * it. If so, the empty page placeholder will be shown
         */
        var determineEmptyAfterSave = function() {
            var cellElements = $('#' + currentPageShown.ref + ' .contentauthoring_cell_element', $rootel);
            var containsText = false;
            $.each(cellElements, function(index, el) {
                if (sakai.api.Util.determineEmptyContent($(el).html())) {
                    containsText = true;
                }
            });
            showPlaceholder(!containsText);
        };

        /**
         * Show or hide the empty page placeholder
         * @param {Boolean} show    True if the placeholder needs to be shown, false
         *                          if it needs to be hidden
         */
        var showPlaceholder = function(show) {
            if (show) {
                sakai.api.Util.TemplateRenderer('contentauthoring_no_content_template', {
                    'canEdit': currentPageShown.canEdit
                }, $('#contentauthoring_no_content_container', $rootel));
            }
            $('#contentauthoring_widget_container', $pageRootEl).toggle(!show);
            $('#contentauthoring_no_content_container', $rootel).toggle(show);
        };

        ////////////////////
        // PAGE RENDERING //
        ////////////////////

        // Render a page
        $(window).on('showpage.contentauthoring.sakai', function(ev, _currentPageShown) {
            processNewPage(_currentPageShown, false);
            // scroll to the top of content if it is off screen
            if ($(window).scrollTop() > $rootel.offset().top) {
                $(window).scrollTop($rootel.offset().top);
            }
        });

        //////////////////
        // KEYBOARD NAV //
        //////////////////

        // cell options
        $rootel.on('keyup', '.contentauthoring_row', function(e) {
            var $container = $(this).parent();
            if (isInEditMode() && (!$container.find('.contentauthoring_row_handle_container').is(':visible') || $container.find('.contentauthoring_row_handle_container').css('visibility') === 'hidden') &&
                $(this).is(':focus') && e.which === $.ui.keyCode.TAB) {
                $('.contentauthoring_row_handle_container', $rootel).css('visibility', 'hidden');
                setRowHoverIn(false, $container);
                $container.find('.contentauthoring_row_handle_container').find('button:visible:first').focus();
            }
        });
        $rootel.on('focus', '.contentauthoring_row_handle_container button', function() {
            hideEditRowMenu();
        });

        // row options
        $rootel.on('keyup', '.contentauthoring_cell_element', function(e) {
            if (e.which === $.ui.keyCode.TAB) {
                showEditCellMenuHoverIn(false, $(this));
            }
        });
        $rootel.on('keydown', '.contentauthoring_cell_element', function(e) {
            if ($('.contentauthoring_cell_element_actions button:last:focus', $(this)).length &&
                e.which === $.ui.keyCode.TAB && !e.shiftKey) {
                $('.contentauthoring_cell_element_actions', $rootel).hide();
            } else if ($(this).is(':focus') && e.which === $.ui.keyCode.TAB && e.shiftKey) {
                showEditCellMenuHoverOut(false, $(this));
            }
        });

        // Insert the default text widget if enter is pressed on a cell
        $rootel.on('keydown', '.contentauthoring_cell', function(e) {
            var $cell = $(this);
            if (isInEditMode() && $cell.is(':focus') && e.which === $.ui.keyCode.ENTER) {
                var $textWidget = $rootel.find('a.inserterbar_text_widget').clone();
                $cell.find('.contentauthoring_cell_content').append($textWidget);
                addNewWidget(null, $textWidget);
            }
        });

        // Change the default filler text to indicate the user can hit enter and begin typing
        $rootel.on('focus', '.contentauthoring_cell', function(e) {
            var $cell = $(this);
            if (isInEditMode() && $cell.is(':focus')) {
                var $dummyEl = $cell.find('.contentauthoring_dummy_element');
                $dummyEl.children('.contentauthoring_dummy_element_dbclick').hide();
                $dummyEl.children('.contentauthoring_dummy_element_enter').show();
            }
        });
        $rootel.on('blur', '.contentauthoring_cell', function(e) {
            var $cell = $(this);
            if (isInEditMode()) {
                var $dummyEl = $cell.find('.contentauthoring_dummy_element');
                $dummyEl.children('.contentauthoring_dummy_element_dbclick').show();
                $dummyEl.children('.contentauthoring_dummy_element_enter').hide();
            }
        });

        /////////////////
        // EDIT WIDGET //
        /////////////////

        // Remove a widget
        $rootel.on('click', '.contentauthoring_cell_element_action_x', removeWidget);

        // Doubleclick on the empty row element
        $rootel.on('dblclick', '.contentauthoring_dummy_element', function(ev) {
            var $el = $(this).attr('data-element-type', 'htmlblock');
            addNewWidget(null, $el);
        });

        // Remove stuck hover highlights
        $rootel.on('mouseout', checkRemoveHighlight);

        /////////////
        // HEIGHTS //
        /////////////

        // Called when an element on the page has the potential of changing the
        // height of the column handles
        $(window).on('updateheight.contentauthoring.sakai', updateColumnHeights);

        ////////////////////
        ////////////////////
        // INITIALIZATION //
        ////////////////////
        ////////////////////

        // Set the contentauthoring ready variable to let the left hand navigation know it can render pages
        sakai_global.contentauthoring.ready = true;
        $(window).trigger('ready.contentauthoring.sakai');

    };
});
