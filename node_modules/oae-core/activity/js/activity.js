/*
 * Licensed to the Sakai Foundation (SF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The SF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

define(['jquery', 'oae.core', 'jquery.timeago', 'jquery.infinitescroll'], function($, oae, timeago, infiniteScroll) {

    return function(uid, showSettings, widgetData) {

        /////////////////////////////
        // Configuration variables //
        /////////////////////////////

        var $rootel = $('#' + uid);

        var infinityScroll = false;

        ///////////////////////
        // Utility functions //
        ///////////////////////

        var handleEmptyResultList = function() {
            oae.api.util.template().render('#activity-noresults-template', {}, $('.oae-list', $rootel));
        };

        /**
         * Callback function to sort comments based on the thread key
         * @param  {Object}   a   comment to sort
         * @param  {Object}   b   comment to sort
         * @return {Number}       returns 0, 1 or -1 depending on the outcome of the condition
         */
        var sortComments = function(a, b) {
            return a['oae:commentThreadKey'].split('#').pop() < b['oae:commentThreadKey'].split('#').pop() ? 1 : -1;
        };

        /**
         * Parses the comments in an activity and makes a tree that can be rendered in the UI.
         * Takes into account replies, orders them correctly and shows one extra comment for context
         * @param  {Object[]}   comments   The array of comments on the activity item
         */
        var constructCommentTree = function(comments) {
            var tree = [];
            // Loop over all the comments that were created in the activity
            for (var i = 0; i < comments.length; i++) {
                // If the comment is a reply, add that reply after the original comment (if it hasn't been added already)
                // If the comment is not a reply, just add it.
                // If the original comment to which has been replied is already in the array, the comment is added after that original comment
                if (comments[i]['oae:replyTo']) {
                    if (tree.length) {
                        var isSet = false;
                        // Loop over the already parsed comments
                        for (var ii = 0; ii < tree.length; ii++) {
                            // If the looped, already in the tree, comment's oae:id matches the replyTo oae:id of the comment to add to the tree
                            // we add it after since it is a reply to that comment
                            if (tree[ii]['oae:id'] === comments[i]['oae:replyTo']['oae:id']) {
                                tree.splice(ii + 1, 0, comments[i]);
                                isSet = true;
                                break;
                            // If the looped comment ID is equal to the comment ID the reply to that comment needs to be added in front of the looped comment.
                            } else if (tree[ii]['oae:id'] === comments[i]['oae:id']) {
                                tree[ii]['oae:replyTo'] = comments[i];
                                tree.splice(ii, 0, comments[i]['oae:replyTo']);
                                isSet = true;
                                break;
                            }
                        }
                        if (!isSet) {
                            tree.push(comments[i]['oae:replyTo']);
                            tree.push(comments[i]);
                        }
                    } else {
                        tree.push(comments[i]['oae:replyTo']);
                        tree.push(comments[i]);
                    }

                } else {
                    var added = false;
                    for (var iii = 0; iii < tree.length; iii++) {
                        if (tree[iii]['oae:id'] === comments[i]['oae:id']) {
                            added = true;
                        }
                    }
                    if (!added) {
                        tree.push(comments[i]);
                    }
                }
            }
            return tree;
        };

        /**
         * Parses activities pre-render to sort comments on thread key
         * @param  {Object}    data    The activity stream for the current user/group
         */
        var parseActivity = function(data) {
            for (var i = 0; i < data.items.length; i++) {
                var activity = data.items[i];


                // First sort based on whether or not entities have an image
                if (activity.actor['oae:collection']) {
                    activity.actor['oae:collection'].sort(_sortEntityCollectionByImage);
                }

                if (activity.object && activity.object['oae:collection']) {
                    activity.object['oae:collection'].sort(_sortEntityCollectionByImage);
                }

                if (activity.target && activity.target['oae:collection']) {
                    activity.target['oae:collection'].sort(_sortEntityCollectionByImage);
                }

                // Sort comment activities so that their comments are ordered for thread depth
                if (activity['oae:activityType'] === 'content-comment' && activity.object['oae:collection']) {
                    activity.object['oae:collection'].sort(sortComments);
                    activity.object['oae:collection'] = activity.object['oae:collection'].splice(0, 2);
                    activity.object['oae:collection'] = constructCommentTree(activity.object['oae:collection']);
                }
            }
            return {'results': data.items};
        };

        /**
         * Retrieves a list of the latest 10 activities for the current user/group and triggers the rendering of the activities
         */
        var getActivity = function() {
            // Disable the previous infinite scroll
            if (infinityScroll) {
                infinityScroll.kill();
            }

            var url = '/api/activity/' + widgetData.principalId;

            // Set up the infinite scroll for the list of search results
            infinityScroll = $('.oae-list', $rootel).infiniteScroll(url, {
                'limit': 10
            }, '#activity-items-template', {
                'postProcessor': function(data) {
                    return parseActivity(data);
                },
                'emptyListProcessor': handleEmptyResultList
            });


        };

        /**
         * Sort entities based on whether or not they have an image associated to them
         * @see Array#sort
         */
        var _sortEntityCollectionByImage = function(one, other) {
            if (one.image && !other.image) {
                return -1;
            } else if (!one.image && other.image) {
                return 1;
            }

            return 0;
        };


        /////////////////////////
        // Main View functions //
        /////////////////////////



        ////////////////////
        // Event Handlers //
        ////////////////////

        var addBinding = function() {

        };


        /////////////////////////////
        // Initialization function //
        /////////////////////////////

        var doInit = function() {
            addBinding();
            getActivity();
        };

        doInit();
    };
});
