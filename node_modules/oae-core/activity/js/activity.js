/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

define(['jquery', 'underscore', 'oae.core'], function($, _, oae) {

    // When this widget is loaded, the user or group object representing the context
    // for which the activity stream needs to be rendered will be passed in as part of the widgetData
    return function(uid, showSettings, widgetData) {

        // The widget container
        var $rootel = $('#' + uid);

        // Variable that will be used to keep track of the current infinite scroll instance
        var infinityScroll = false;

        /**
         * Sort entities based on whether or not they have a thumbnail. Entities with
         * thumbnails will be listed in front of those with no thumbnails, as we give
         * preference to these for UI rendering purposes.
         *
         * @see Array#sort
         */
        var sortEntityCollection = function(a, b) {
            if (a.image && !b.image) {
                return -1;
            } else if (!a.image && b.image) {
                return 1;
            }
            return 0;
        };

        /**
         * Sort comments based on when they have been created. The comments list will be
         * ordered from new to old.
         *
         * @see Array#sort
         */
        var sortComments = function(a, b) {
            // Threadkeys will have the following format, primarily to allow for proper thread ordering:
            //  - Top level comments: <createdTimeStamp>|
            //  - Reply: <parentCreatedTimeStamp>#<createdTimeStamp>|
            if (a['oae:threadKey'].split('#').pop() < b['oae:threadKey'].split('#').pop()) {
                return 1;
            } else {
                return -1;
            }
        };

        /**
         * Process a list of comments into an ordered tree that contains the comments they were replies to, if any,
         * as well as the level at which all of these comments need to be rendered.
         *
         * @param  {Comment[]}   comments   The array of latest comments to turn into an ordered tree
         * @return {Comment[]}              The ordered tree of comments with an `oae:level` property for each comment, representing the level at which they should be rendered
         */
        var constructCommentTree = function(comments) {
            var orderedTree = [];

            // If the comment is a reply to a different comment, we add that comment to the ordered tree as well,
            // in order to provide some context for the current comment
            $.each(comments, function(index, comment) {
                // Check if the comment is already in the ordered tree, because of a reply to this comment
                var exists = _.findWhere(orderedTree, {'published': comment.published});
                if (!exists) {
                    if (comment.inReplyTo) {
                        // Check if the parent comment is already present in the ordered tree
                        var parentExists = _.findWhere(orderedTree, {'published': comment.inReplyTo.published});
                        // If it isn't, we add it to the ordered list, just ahead of the current comment
                        if (!parentExists) {
                            orderedTree.push(comment.inReplyTo);
                        }
                    }
                    orderedTree.push(comment);
                }
            });

            // Now that all comments and the comments they were replies to are in the ordered list, we add a level
            // to each of them. These levels will be relative to each other, starting at 0 for top-level comments.
            $.each(orderedTree, function(index, comment) {
                comment['oae:level'] = 0;
                // If the comment is a reply to a comment, we set its level to be that of its parent + 1
                if (comment.inReplyTo) {
                    var replyTo = _.findWhere(orderedTree, {'published': comment.inReplyTo.published});
                    comment['oae:level'] = replyTo['oae:level'] + 1;
                }
            });

            return orderedTree;
        };

        /**
         * Utility function that will determine whether or not all of the comments from the activity
         * are present in the final ordered tree. If not, a "Show all" link will be added to the UI.
         *
         * @param  {Comment[]}      originalComments        List of orginal comments on the activity
         * @param  {Comment[]}      orderedComments         Ordered list of comments containing the latest comments only with the comments they were replies to, if any
         * @return {Boolean}                                Whether or not all of the comments from the original activity are included in the ordered tree
         */
        var includesAllComments = function(originalComments, orderedComments) {
            var hasAllComments = true;
            $.each(originalComments, function(index, comment) {
                var inOrderedComments = _.findWhere(orderedComments, {'oae:id': comment['oae:id']});
                if (!inOrderedComments) {
                    hasAllComments = false;
                }
            });
            return hasAllComments;
        };

        /**
         * Process the incoming activities by sorting all entity collections on whether or not they have
         * thumbnail images, as we give preference to these for UI rendering purposes. For activities
         * that involve comments, we also order the comments by date to make sure that we only show the
         * latest comments.
         *
         * @param  {Object}    data    The activity stream for the current context per the activitystrea.ms spec
         */
        var processActivities = function(data) {
            $.each(data.items, function(index, activity) {
                // Sort the entity collections based on whether or not they have a thumbnail
                if (activity.actor['oae:collection']) {
                    // Reverse the items so the item that was changed last is shown first
                    activity.actor['oae:collection'].reverse().sort(sortEntityCollection);
                }

                if (activity.object && activity.object['oae:collection']) {
                    // Reverse the items so the item that was changed last is shown first
                    activity.object['oae:collection'].reverse().sort(sortEntityCollection);
                }

                if (activity.target && activity.target['oae:collection']) {
                    // Reverse the items so the item that was changed last is shown first
                    activity.target['oae:collection'].reverse().sort(sortEntityCollection);
                }

                // For comments, we process the comments into an ordered tree that contains the latest
                // 2 comments and the comments they were replies to, if any
                if (activity['oae:activityType'] === 'content-comment' || activity['oae:activityType'] === 'discussion-message') {
                    var comments = activity.object['oae:collection'];
                    if (!comments) {
                        comments = [activity.object];
                    }
                    // Keep track of the full list of comments on the activity. This will be used to check
                    // whether or not all comments on the activity have made it into the final ordered list
                    var originalComments = comments.slice();

                    // Sort the comments based on the created timestamp
                    comments.sort(sortComments);
                    // Extract the 2 latest comments
                    comments = comments.splice(0, 2);
                    // Convert these comments into an ordered tree that also includes the comments they were
                    // replies to, if any
                    comments = constructCommentTree(comments);
                    // Check if any of the comments that were part of the original activity have not made it
                    // into the ordered tree
                    var hasAllComments = includesAllComments(originalComments, comments);

                    activity.object.objectType = 'comments';
                    activity.object['oae:collection'] = comments;
                    activity.object.hasAllComments = hasAllComments;
                }
            });
            return {
                'context': widgetData.context.id,
                'results': data.items
            };
        };

        /**
         * Subscribe to activity push notifications, allowing for activities that happen after the initial
         * pageload to be added to the activity stream.
         */
        var setUpPushNotifications = function() {
            oae.api.push.subscribe(widgetData.context.id, 'activity', widgetData.context.signature, 'activitystreams', true, function(activity) {
                // Keep track of the current height of the overall document and the current
                // scroll position in the document. This is used to determine whether or not
                // the scroll position needs to be adjusted after the new items have been prepended
                var documentHeight = $(document).height();
                var scrollPosition = $(document).scrollTop();

                // Prepend the new activity item to the activity stream. A copy of the activity is
                // taken to avoid modifying the original activity when post-processing the activity
                infinityScroll.prependItems({
                    'items': [$.extend(true, {}, activity)]
                });

                // Only consider changing the scroll position when the widget is currently visible
                if ($rootel.is(':visible')) {
                    // When the user is scrolled down at least one full screen, the scroll position is adjusted
                    // to still be in the same place for the user after prepending the new items. When the user
                    // is scrolled down less than a full screen, the scroll position remains unchanged
                    var newDocumentHeight = $(document).height();
                    if (scrollPosition > $(window).height()) {
                        $(document).scrollTop(scrollPosition + (newDocumentHeight - documentHeight));
                    }
                }
            });
        };

        /**
         * Initialize a new infinite scroll container that fetches the activity stream
         * for the current context.
         */
        var getActivity = function() {
            // Disable the previous infinite scroll
            if (infinityScroll) {
                infinityScroll.kill();
            }

            var url = '/api/activity/' + widgetData.context.id;

            // Set up the infinite scroll for the activity stream
            infinityScroll = $('.oae-list', $rootel).infiniteScroll(url, {
                'limit': 10
            }, '#activity-items-template', {
                'postProcessor': processActivities,
                'emptyListProcessor': handleEmptyResultList
            });
        };

        /**
         * Show the empty list message when no results are found. This function will
         * be called by the infinite scroll plugin.
         */
        var handleEmptyResultList = function() {
            oae.api.util.template().render($('#activity-noresults-template', $rootel), null, $('.oae-list', $rootel));
        };

        setUpPushNotifications();
        getActivity();

    };
});
